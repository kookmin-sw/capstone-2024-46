// Package openai provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package openai

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ContentType.
const (
	ContentTypeImageFile ContentType = "image_file"
	ContentTypeText      ContentType = "text"
)

// Defines values for CreateMessageRequestRole.
const (
	CreateMessageRequestRoleUser CreateMessageRequestRole = "user"
)

// Defines values for LastErrorCode.
const (
	RateLimitExceeded LastErrorCode = "rate_limit_exceeded"
	ServerError       LastErrorCode = "server_error"
)

// Defines values for RequiredActionType.
const (
	SubmitToolOutputs RequiredActionType = "submit_tool_outputs"
)

// Defines values for RunStatus.
const (
	Cancelled      RunStatus = "cancelled"
	Cancelling     RunStatus = "cancelling"
	Completed      RunStatus = "completed"
	Expired        RunStatus = "expired"
	Failed         RunStatus = "failed"
	InProgress     RunStatus = "in_progress"
	Queued         RunStatus = "queued"
	RequiresAction RunStatus = "requires_action"
)

// Defines values for TextAnnotationType.
const (
	FileCitation TextAnnotationType = "file_citation"
	FilePath     TextAnnotationType = "file_path"
)

// Defines values for ThreadMessageRole.
const (
	ThreadMessageRoleAssistant ThreadMessageRole = "assistant"
	ThreadMessageRoleUser      ThreadMessageRole = "user"
)

// Defines values for ToolType.
const (
	ToolTypeCodeInterpreter ToolType = "code_interpreter"
	ToolTypeFunction        ToolType = "function"
	ToolTypeRetrieval       ToolType = "retrieval"
)

// Content defines model for Content.
type Content struct {
	// ImageFile image_file will be returned when type is `image_file`
	ImageFile *ImageFile `json:"image_file,omitempty"`

	// Text text will be returned when type is `text`
	Text *Text       `json:"text,omitempty"`
	Type ContentType `json:"type"`
}

// ContentType defines model for Content.Type.
type ContentType string

// CreateMessageRequest defines model for CreateMessageRequest.
type CreateMessageRequest struct {
	// Content The content of the new message.
	Content string `json:"content"`

	// FileIds A list of File IDs the message should use, supporting up to 10 files.
	FileIds *[]string `json:"file_ids,omitempty"`

	// Metadata Optional metadata as key-value pairs for additional information about the message.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Role The role of the entity creating the message. Currently, only 'user' is supported.
	Role CreateMessageRequestRole `json:"role"`
}

// CreateMessageRequestRole The role of the entity creating the message. Currently, only 'user' is supported.
type CreateMessageRequestRole string

// CreateRunRequest Request message for creating a run within a thread.
type CreateRunRequest struct {
	// AdditionalInstructions Appends additional instructions at the end of the instructions for the run.
	//  Useful for modifying behavior without overriding other instructions.
	AdditionalInstructions *string `json:"additional_instructions,omitempty"`

	// AssistantId The ID of the assistant to use for executing this run.
	AssistantId string `json:"assistant_id"`

	// Instructions Overrides the instructions of the assistant. This is useful for
	//  modifying behavior on a per-run basis.
	Instructions *string `json:"instructions,omitempty"`

	// Metadata Set of 16 key-value pairs for storing additional information in a structured format.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Model The ID of the model to be used for this run. Overrides the model associated with the assistant.
	Model *string `json:"model,omitempty"`

	// Tools List of tools the assistant can use for this run. Useful for modifying behavior per run.
	Tools *[]Tool `json:"tools,omitempty"`
}

// Function defines model for Function.
type Function struct {
	// Arguments The arguments that the model expects you to pass to the function.
	Arguments string `json:"arguments"`

	// Name The name of the function.
	Name string `json:"name"`
}

// ImageFile defines model for ImageFile.
type ImageFile struct {
	// FileId ID of the image in the message content.
	FileId string `json:"file_id"`
}

// LastError defines model for LastError.
type LastError struct {
	// Code Error code associated with the last error.
	Code LastErrorCode `json:"code"`

	// Message Error message associated with the last error.
	Message string `json:"message"`
}

// LastErrorCode Error code associated with the last error.
type LastErrorCode string

// ListMessagesResponse Response message containing a list of messages.
type ListMessagesResponse struct {
	// Data List of messages in the specified thread.
	Data    *[]ThreadMessage `json:"data,omitempty"`
	FirstId *string          `json:"first_id,omitempty"`
	HasMore *bool            `json:"has_more,omitempty"`
	LastId  *string          `json:"last_id,omitempty"`
}

// RequiredAction defines model for RequiredAction.
type RequiredAction struct {
	// SubmitToolOutputs Action required to continue the run.
	SubmitToolOutputs RequiredActionSubmitToolOutputs `json:"submit_tool_outputs"`

	// Type For now, this is always `submit_tool_outputs`
	Type RequiredActionType `json:"type"`
}

// RequiredActionType For now, this is always `submit_tool_outputs`
type RequiredActionType string

// RequiredActionFunctionToolCall defines model for RequiredActionFunctionToolCall.
type RequiredActionFunctionToolCall struct {
	// Function The function definition.
	Function Function `json:"function"`

	// Id The ID of the tool call.
	Id string `json:"id"`
}

// RequiredActionSubmitToolOutputs defines model for RequiredActionSubmitToolOutputs.
type RequiredActionSubmitToolOutputs struct {
	// ToolCalls A list of the relevant tool calls.
	ToolCalls *[]RequiredActionFunctionToolCall `json:"tool_calls,omitempty"`
}

// Run Response message representing a run.
type Run struct {
	// AssistantId Assistant ID used for execution of this run.
	AssistantId string `json:"assistant_id"`

	// CancelledAt Unix timestamp (in seconds) for when the run was cancelled. Optional.
	CancelledAt *uint32 `json:"cancelled_at,omitempty"`

	// CompletedAt Unix timestamp (in seconds) for when the run was completed. Optional.
	CompletedAt *uint32 `json:"completed_at,omitempty"`

	// CreatedAt Unix timestamp (in seconds) for when the run was created.
	CreatedAt uint32 `json:"created_at"`

	// ExpiresAt Unix timestamp (in seconds) for when the run will expire.
	ExpiresAt uint32 `json:"expires_at"`

	// FailedAt Unix timestamp (in seconds) for when the run failed. Optional.
	FailedAt *uint32 `json:"failed_at,omitempty"`

	// FileIds List of File IDs the assistant used for this run.
	FileIds *[]string `json:"file_ids,omitempty"`

	// Id Unique identifier for the run.
	Id string `json:"id"`

	// Instructions Instructions the assistant used for this run.
	Instructions string `json:"instructions"`

	// LastError Last error associated with this run. Null if there are no errors.
	LastError *LastError `json:"last_error,omitempty"`

	// Metadata Set of 16 key-value pairs for storing additional information in a structured format.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Model Model used by the assistant for this run.
	Model string `json:"model"`

	// Object Always `thread.run`. Indicates the object type.
	Object string `json:"object"`

	// RequiredAction Action required to continue the run. Null if no action is required.
	RequiredAction *RequiredAction `json:"required_action,omitempty"`

	// StartedAt Unix timestamp (in seconds) for when the run was started. Optional.
	StartedAt *uint32 `json:"started_at,omitempty"`

	// Status Current status of the run (e.g., queued, in_progress, completed).
	Status RunStatus `json:"status"`

	// ThreadId Thread ID that was executed on as part of this run.
	ThreadId string `json:"thread_id"`

	// Tools List of tools used by the assistant for this run.
	Tools *[]Tool `json:"tools,omitempty"`

	// Usage Usage statistics related to the run. Null if run is not in a terminal state.
	Usage *Usage `json:"usage,omitempty"`
}

// RunStatus Current status of the run (e.g., queued, in_progress, completed).
type RunStatus string

// Text defines model for Text.
type Text struct {
	Annotations *[]TextAnnotation `json:"annotations,omitempty"`
	Value       string            `json:"value"`
}

// TextAnnotation defines model for TextAnnotation.
type TextAnnotation struct {
	EndIndex int32 `json:"end_index"`

	// FileCitation file_citation will be returned when type is `file_citation`
	FileCitation *TextAnnotationTextAnnotationFileCitationFileCitation `json:"file_citation,omitempty"`

	// FilePath file_path will be returned when type is `file_path`
	FilePath   *TextAnnotationTextAnnotationFilePathFilePath `json:"file_path,omitempty"`
	StartIndex int32                                         `json:"start_index"`

	// Text The text in the message content that needs to be replaced.
	Text string             `json:"text"`
	Type TextAnnotationType `json:"type"`
}

// TextAnnotationType defines model for TextAnnotation.Type.
type TextAnnotationType string

// TextAnnotationTextAnnotationFileCitationFileCitation defines model for TextAnnotation_TextAnnotationFileCitationFileCitation.
type TextAnnotationTextAnnotationFileCitationFileCitation struct {
	// FileId The ID of the specific File the citation is from.
	FileId string `json:"file_id"`

	// Quote The specific quote in the file.
	Quote string `json:"quote"`
}

// TextAnnotationTextAnnotationFilePathFilePath defines model for TextAnnotation_TextAnnotationFilePathFilePath.
type TextAnnotationTextAnnotationFilePathFilePath struct {
	FileId string `json:"file_id"`
}

// Thread defines model for Thread.
type Thread struct {
	// CreatedAt The Unix timestamp (in seconds) of when the thread was created.
	CreatedAt uint32 `json:"created_at"`

	// Id A unique identifier for the created thread.
	Id string `json:"id"`

	// Metadata Set of 16 key-value pairs that can be attached to an object.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Object The object type, which is always `thread`.
	Object string `json:"object"`
}

// ThreadMessage Representation of a message within a thread.
type ThreadMessage struct {
	// AssistantId ID of the assistant that authored this message.
	AssistantId *string `json:"assistant_id,omitempty"`

	// Content Content of the message, including text and/or images.
	Content *[]Content `json:"content,omitempty"`

	// CreatedAt Unix timestamp (in seconds) for when the message was created.
	CreatedAt uint32 `json:"created_at"`

	// FileIds List of file IDs associated with this message. Maximum of 10 files.
	FileIds *[]string `json:"file_ids,omitempty"`

	// Id Unique identifier for the message.
	Id string `json:"id"`

	// Metadata Optional. Metadata associated with the message as key-value pairs.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Object Object type, always `thread.message`.
	Object string `json:"object"`

	// Role The role of the entity that produced the message, either `user` or `assistant`.
	Role ThreadMessageRole `json:"role"`

	// RunId The run ID associated with the authoring of this message.
	RunId *string `json:"run_id,omitempty"`

	// ThreadId The thread ID to which this message belongs.
	ThreadId string `json:"thread_id"`
}

// ThreadMessageRole The role of the entity that produced the message, either `user` or `assistant`.
type ThreadMessageRole string

// Tool defines model for Tool.
type Tool struct {
	Function *ToolFunctionDefinition `json:"function,omitempty"`
	Type     *ToolType               `json:"type,omitempty"`
}

// ToolType defines model for Tool.Type.
type ToolType string

// ToolFunctionDefinition defines model for Tool_FunctionDefinition.
type ToolFunctionDefinition struct {
	Description *string                 `json:"description,omitempty"`
	Name        string                  `json:"name"`
	Parameters  *map[string]interface{} `json:"parameters,omitempty"`
}

// Usage defines model for Usage.
type Usage struct {
	// CompletionTokens Number of completion tokens used over the course of the run.
	CompletionTokens int32 `json:"completion_tokens"`

	// PromptTokens Number of prompt tokens used over the course of the run.
	PromptTokens int32 `json:"prompt_tokens"`

	// TotalTokens Total number of tokens used (prompt + completion).
	TotalTokens int32 `json:"total_tokens"`
}

// ThreadServiceCreateThreadParams defines parameters for ThreadServiceCreateThread.
type ThreadServiceCreateThreadParams struct {
	OpenAIBeta string `json:"OpenAI-Beta"`
}

// ThreadServiceListMessagesParams defines parameters for ThreadServiceListMessages.
type ThreadServiceListMessagesParams struct {
	// After A cursor for pagination, specifying the object ID to list messages after.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for pagination, specifying the object ID to list messages before.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// Limit Limit on the number of messages to be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Order of messages based on their creation timestamp. Can be 'asc' or 'desc'.
	Order      *string `form:"order,omitempty" json:"order,omitempty"`
	OpenAIBeta string  `json:"OpenAI-Beta"`
}

// ThreadServiceCreateMessageParams defines parameters for ThreadServiceCreateMessage.
type ThreadServiceCreateMessageParams struct {
	OpenAIBeta string `json:"OpenAI-Beta"`
}

// ThreadServiceCreateRunParams defines parameters for ThreadServiceCreateRun.
type ThreadServiceCreateRunParams struct {
	OpenAIBeta string `json:"OpenAI-Beta"`
}

// ThreadServiceRetrieveRunParams defines parameters for ThreadServiceRetrieveRun.
type ThreadServiceRetrieveRunParams struct {
	OpenAIBeta string `json:"OpenAI-Beta"`
}

// ThreadServiceCreateMessageJSONRequestBody defines body for ThreadServiceCreateMessage for application/json ContentType.
type ThreadServiceCreateMessageJSONRequestBody = CreateMessageRequest

// ThreadServiceCreateRunJSONRequestBody defines body for ThreadServiceCreateRun for application/json ContentType.
type ThreadServiceCreateRunJSONRequestBody = CreateRunRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ThreadServiceCreateThread request
	ThreadServiceCreateThread(ctx context.Context, params *ThreadServiceCreateThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThreadServiceListMessages request
	ThreadServiceListMessages(ctx context.Context, threadId string, params *ThreadServiceListMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThreadServiceCreateMessageWithBody request with any body
	ThreadServiceCreateMessageWithBody(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ThreadServiceCreateMessage(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, body ThreadServiceCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThreadServiceCreateRunWithBody request with any body
	ThreadServiceCreateRunWithBody(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ThreadServiceCreateRun(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, body ThreadServiceCreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThreadServiceRetrieveRun request
	ThreadServiceRetrieveRun(ctx context.Context, threadId string, runId string, params *ThreadServiceRetrieveRunParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ThreadServiceCreateThread(ctx context.Context, params *ThreadServiceCreateThreadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadServiceCreateThreadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadServiceListMessages(ctx context.Context, threadId string, params *ThreadServiceListMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadServiceListMessagesRequest(c.Server, threadId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadServiceCreateMessageWithBody(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadServiceCreateMessageRequestWithBody(c.Server, threadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadServiceCreateMessage(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, body ThreadServiceCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadServiceCreateMessageRequest(c.Server, threadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadServiceCreateRunWithBody(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadServiceCreateRunRequestWithBody(c.Server, threadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadServiceCreateRun(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, body ThreadServiceCreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadServiceCreateRunRequest(c.Server, threadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThreadServiceRetrieveRun(ctx context.Context, threadId string, runId string, params *ThreadServiceRetrieveRunParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThreadServiceRetrieveRunRequest(c.Server, threadId, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewThreadServiceCreateThreadRequest generates requests for ThreadServiceCreateThread
func NewThreadServiceCreateThreadRequest(server string, params *ThreadServiceCreateThreadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/threads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "OpenAI-Beta", runtime.ParamLocationHeader, params.OpenAIBeta)
		if err != nil {
			return nil, err
		}

		req.Header.Set("OpenAI-Beta", headerParam0)

	}

	return req, nil
}

// NewThreadServiceListMessagesRequest generates requests for ThreadServiceListMessages
func NewThreadServiceListMessagesRequest(server string, threadId string, params *ThreadServiceListMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/threads/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "OpenAI-Beta", runtime.ParamLocationHeader, params.OpenAIBeta)
		if err != nil {
			return nil, err
		}

		req.Header.Set("OpenAI-Beta", headerParam0)

	}

	return req, nil
}

// NewThreadServiceCreateMessageRequest calls the generic ThreadServiceCreateMessage builder with application/json body
func NewThreadServiceCreateMessageRequest(server string, threadId string, params *ThreadServiceCreateMessageParams, body ThreadServiceCreateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewThreadServiceCreateMessageRequestWithBody(server, threadId, params, "application/json", bodyReader)
}

// NewThreadServiceCreateMessageRequestWithBody generates requests for ThreadServiceCreateMessage with any type of body
func NewThreadServiceCreateMessageRequestWithBody(server string, threadId string, params *ThreadServiceCreateMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/threads/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "OpenAI-Beta", runtime.ParamLocationHeader, params.OpenAIBeta)
		if err != nil {
			return nil, err
		}

		req.Header.Set("OpenAI-Beta", headerParam0)

	}

	return req, nil
}

// NewThreadServiceCreateRunRequest calls the generic ThreadServiceCreateRun builder with application/json body
func NewThreadServiceCreateRunRequest(server string, threadId string, params *ThreadServiceCreateRunParams, body ThreadServiceCreateRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewThreadServiceCreateRunRequestWithBody(server, threadId, params, "application/json", bodyReader)
}

// NewThreadServiceCreateRunRequestWithBody generates requests for ThreadServiceCreateRun with any type of body
func NewThreadServiceCreateRunRequestWithBody(server string, threadId string, params *ThreadServiceCreateRunParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/threads/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "OpenAI-Beta", runtime.ParamLocationHeader, params.OpenAIBeta)
		if err != nil {
			return nil, err
		}

		req.Header.Set("OpenAI-Beta", headerParam0)

	}

	return req, nil
}

// NewThreadServiceRetrieveRunRequest generates requests for ThreadServiceRetrieveRun
func NewThreadServiceRetrieveRunRequest(server string, threadId string, runId string, params *ThreadServiceRetrieveRunParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/threads/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "OpenAI-Beta", runtime.ParamLocationHeader, params.OpenAIBeta)
		if err != nil {
			return nil, err
		}

		req.Header.Set("OpenAI-Beta", headerParam0)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ThreadServiceCreateThreadWithResponse request
	ThreadServiceCreateThreadWithResponse(ctx context.Context, params *ThreadServiceCreateThreadParams, reqEditors ...RequestEditorFn) (*ThreadServiceCreateThreadResponse, error)

	// ThreadServiceListMessagesWithResponse request
	ThreadServiceListMessagesWithResponse(ctx context.Context, threadId string, params *ThreadServiceListMessagesParams, reqEditors ...RequestEditorFn) (*ThreadServiceListMessagesResponse, error)

	// ThreadServiceCreateMessageWithBodyWithResponse request with any body
	ThreadServiceCreateMessageWithBodyWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThreadServiceCreateMessageResponse, error)

	ThreadServiceCreateMessageWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, body ThreadServiceCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ThreadServiceCreateMessageResponse, error)

	// ThreadServiceCreateRunWithBodyWithResponse request with any body
	ThreadServiceCreateRunWithBodyWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThreadServiceCreateRunResponse, error)

	ThreadServiceCreateRunWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, body ThreadServiceCreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ThreadServiceCreateRunResponse, error)

	// ThreadServiceRetrieveRunWithResponse request
	ThreadServiceRetrieveRunWithResponse(ctx context.Context, threadId string, runId string, params *ThreadServiceRetrieveRunParams, reqEditors ...RequestEditorFn) (*ThreadServiceRetrieveRunResponse, error)
}

type ThreadServiceCreateThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Thread
}

// Status returns HTTPResponse.Status
func (r ThreadServiceCreateThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThreadServiceCreateThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThreadServiceListMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMessagesResponse
}

// Status returns HTTPResponse.Status
func (r ThreadServiceListMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThreadServiceListMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThreadServiceCreateMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreadMessage
}

// Status returns HTTPResponse.Status
func (r ThreadServiceCreateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThreadServiceCreateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThreadServiceCreateRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Run
}

// Status returns HTTPResponse.Status
func (r ThreadServiceCreateRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThreadServiceCreateRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThreadServiceRetrieveRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Run
}

// Status returns HTTPResponse.Status
func (r ThreadServiceRetrieveRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThreadServiceRetrieveRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ThreadServiceCreateThreadWithResponse request returning *ThreadServiceCreateThreadResponse
func (c *ClientWithResponses) ThreadServiceCreateThreadWithResponse(ctx context.Context, params *ThreadServiceCreateThreadParams, reqEditors ...RequestEditorFn) (*ThreadServiceCreateThreadResponse, error) {
	rsp, err := c.ThreadServiceCreateThread(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadServiceCreateThreadResponse(rsp)
}

// ThreadServiceListMessagesWithResponse request returning *ThreadServiceListMessagesResponse
func (c *ClientWithResponses) ThreadServiceListMessagesWithResponse(ctx context.Context, threadId string, params *ThreadServiceListMessagesParams, reqEditors ...RequestEditorFn) (*ThreadServiceListMessagesResponse, error) {
	rsp, err := c.ThreadServiceListMessages(ctx, threadId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadServiceListMessagesResponse(rsp)
}

// ThreadServiceCreateMessageWithBodyWithResponse request with arbitrary body returning *ThreadServiceCreateMessageResponse
func (c *ClientWithResponses) ThreadServiceCreateMessageWithBodyWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThreadServiceCreateMessageResponse, error) {
	rsp, err := c.ThreadServiceCreateMessageWithBody(ctx, threadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadServiceCreateMessageResponse(rsp)
}

func (c *ClientWithResponses) ThreadServiceCreateMessageWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateMessageParams, body ThreadServiceCreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ThreadServiceCreateMessageResponse, error) {
	rsp, err := c.ThreadServiceCreateMessage(ctx, threadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadServiceCreateMessageResponse(rsp)
}

// ThreadServiceCreateRunWithBodyWithResponse request with arbitrary body returning *ThreadServiceCreateRunResponse
func (c *ClientWithResponses) ThreadServiceCreateRunWithBodyWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ThreadServiceCreateRunResponse, error) {
	rsp, err := c.ThreadServiceCreateRunWithBody(ctx, threadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadServiceCreateRunResponse(rsp)
}

func (c *ClientWithResponses) ThreadServiceCreateRunWithResponse(ctx context.Context, threadId string, params *ThreadServiceCreateRunParams, body ThreadServiceCreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ThreadServiceCreateRunResponse, error) {
	rsp, err := c.ThreadServiceCreateRun(ctx, threadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadServiceCreateRunResponse(rsp)
}

// ThreadServiceRetrieveRunWithResponse request returning *ThreadServiceRetrieveRunResponse
func (c *ClientWithResponses) ThreadServiceRetrieveRunWithResponse(ctx context.Context, threadId string, runId string, params *ThreadServiceRetrieveRunParams, reqEditors ...RequestEditorFn) (*ThreadServiceRetrieveRunResponse, error) {
	rsp, err := c.ThreadServiceRetrieveRun(ctx, threadId, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThreadServiceRetrieveRunResponse(rsp)
}

// ParseThreadServiceCreateThreadResponse parses an HTTP response from a ThreadServiceCreateThreadWithResponse call
func ParseThreadServiceCreateThreadResponse(rsp *http.Response) (*ThreadServiceCreateThreadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThreadServiceCreateThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Thread
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseThreadServiceListMessagesResponse parses an HTTP response from a ThreadServiceListMessagesWithResponse call
func ParseThreadServiceListMessagesResponse(rsp *http.Response) (*ThreadServiceListMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThreadServiceListMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMessagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseThreadServiceCreateMessageResponse parses an HTTP response from a ThreadServiceCreateMessageWithResponse call
func ParseThreadServiceCreateMessageResponse(rsp *http.Response) (*ThreadServiceCreateMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThreadServiceCreateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreadMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseThreadServiceCreateRunResponse parses an HTTP response from a ThreadServiceCreateRunWithResponse call
func ParseThreadServiceCreateRunResponse(rsp *http.Response) (*ThreadServiceCreateRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThreadServiceCreateRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Run
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseThreadServiceRetrieveRunResponse parses an HTTP response from a ThreadServiceRetrieveRunWithResponse call
func ParseThreadServiceRetrieveRunResponse(rsp *http.Response) (*ThreadServiceRetrieveRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThreadServiceRetrieveRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Run
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
